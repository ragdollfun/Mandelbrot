-- -------------------------------------------------------------
-- 
-- File Name: C:\Users\Petr\AppData\Local\Temp\mlhdlc_mandelbrot_calculator\codegen\mandelbrot_calculator\hdlsrc\mandelbrot_calculator_tb.vhd
-- 
-- Generated by MATLAB 9.10, MATLAB Coder 5.2 and HDL Coder 3.18
-- 
-- 
-- 
-- -------------------------------------------------------------
-- Rate and Clocking Details
-- -------------------------------------------------------------
-- Model base rate: 1
-- Target subsystem base rate: 1
-- 
-- -------------------------------------------------------------


-- -------------------------------------------------------------
-- 
-- Module: mandelbrot_calculator_tb
-- Source Path: 
-- Hierarchy Level: 0
-- 
-- -------------------------------------------------------------
LIBRARY IEEE;
USE IEEE.std_logic_textio.ALL;
USE IEEE.std_logic_1164.ALL;
USE IEEE.numeric_std.ALL;
LIBRARY STD;
USE STD.textio.ALL;
USE work.mandelbrot_calculator_tb_pkg.ALL;

ENTITY mandelbrot_calculator_tb IS
END mandelbrot_calculator_tb;


ARCHITECTURE simulation OF mandelbrot_calculator_tb IS

  -- Component Declarations
  COMPONENT mandelbrot_calculator
    PORT( clk                             :   IN    std_logic;
          rst                             :   IN    std_logic;
          start                           :   IN    std_logic;
          c_real                          :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          c_imaginary                     :   IN    std_logic_vector(15 DOWNTO 0);  -- sfix16_En14
          ready                           :   OUT   std_logic;
          finished                        :   OUT   std_logic;
          z_real                          :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
          z_imaginary                     :   OUT   std_logic_vector(15 DOWNTO 0);  -- sfix16_En12
          iterations                      :   OUT   std_logic_vector(6 DOWNTO 0)  -- ufix7
          );
  END COMPONENT;

  -- Component Configuration Statements
  FOR ALL : mandelbrot_calculator
    USE ENTITY work.mandelbrot_calculator(rtl);

  -- Signals
  SIGNAL clk                              : std_logic;
  SIGNAL rst                              : std_logic;
  SIGNAL enb                              : std_logic;
  SIGNAL iterations_done                  : std_logic;  -- ufix1
  SIGNAL rdEnb                            : std_logic;
  SIGNAL iterations_done_enb              : std_logic;  -- ufix1
  SIGNAL ready_addr                       : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL iterations_lastAddr              : std_logic;  -- ufix1
  SIGNAL resetn                           : std_logic;
  SIGNAL check5_done                      : std_logic;  -- ufix1
  SIGNAL z_imaginary_done                 : std_logic;  -- ufix1
  SIGNAL z_imaginary_done_enb             : std_logic;  -- ufix1
  SIGNAL z_imaginary_lastAddr             : std_logic;  -- ufix1
  SIGNAL check4_done                      : std_logic;  -- ufix1
  SIGNAL z_real_done                      : std_logic;  -- ufix1
  SIGNAL z_real_done_enb                  : std_logic;  -- ufix1
  SIGNAL z_real_lastAddr                  : std_logic;  -- ufix1
  SIGNAL check3_done                      : std_logic;  -- ufix1
  SIGNAL finished_done                    : std_logic;  -- ufix1
  SIGNAL finished_done_enb                : std_logic;  -- ufix1
  SIGNAL finished_lastAddr                : std_logic;  -- ufix1
  SIGNAL check2_done                      : std_logic;  -- ufix1
  SIGNAL ready_done                       : std_logic;  -- ufix1
  SIGNAL ready_done_enb                   : std_logic;  -- ufix1
  SIGNAL ready_active                     : std_logic;  -- ufix1
  SIGNAL snkDone                          : std_logic;
  SIGNAL snkDonen                         : std_logic;
  SIGNAL tb_enb                           : std_logic;
  SIGNAL alpha2                           : std_logic;
  SIGNAL ready_enb                        : std_logic;  -- ufix1
  SIGNAL ready_lastAddr                   : std_logic;  -- ufix1
  SIGNAL check1_done                      : std_logic;  -- ufix1
  SIGNAL rawData_start                    : std_logic;
  SIGNAL holdData_start                   : std_logic;
  SIGNAL start_offset                     : std_logic;
  SIGNAL start_1                          : std_logic;
  SIGNAL start_addr                       : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL start_active                     : std_logic;  -- ufix1
  SIGNAL start_enb                        : std_logic;  -- ufix1
  SIGNAL c_real_addr_delay_1              : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL rawData_c_real                   : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL holdData_c_real                  : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL c_real_offset                    : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL c_real                           : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL c_real_1                         : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL c_imaginary_addr_delay_1         : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL rawData_c_imaginary              : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL holdData_c_imaginary             : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL c_imaginary_offset               : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL c_imaginary                      : signed(15 DOWNTO 0);  -- sfix16_En14
  SIGNAL c_imaginary_1                    : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL ready_1                          : std_logic;
  SIGNAL finished                         : std_logic;
  SIGNAL z_real                           : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL z_imaginary                      : std_logic_vector(15 DOWNTO 0);  -- ufix16
  SIGNAL iterations                       : std_logic_vector(6 DOWNTO 0);  -- ufix7
  SIGNAL ready_addr_delay_1               : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL ready_expected                   : std_logic;
  SIGNAL ready_ref                        : std_logic;
  SIGNAL ready_testFailure                : std_logic;  -- ufix1
  SIGNAL finished_addr_delay_1            : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL finished_expected                : std_logic;
  SIGNAL finished_ref                     : std_logic;
  SIGNAL finished_testFailure             : std_logic;  -- ufix1
  SIGNAL z_real_signed                    : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL z_real_addr_delay_1              : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL z_real_expected                  : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL z_real_ref                       : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL z_real_testFailure               : std_logic;  -- ufix1
  SIGNAL z_imaginary_signed               : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL z_imaginary_addr_delay_1         : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL z_imaginary_expected             : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL z_imaginary_ref                  : signed(15 DOWNTO 0);  -- sfix16_En12
  SIGNAL z_imaginary_testFailure          : std_logic;  -- ufix1
  SIGNAL iterations_unsigned              : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterations_addr_delay_1          : unsigned(22 DOWNTO 0);  -- ufix23
  SIGNAL iterations_expected              : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterations_ref                   : unsigned(6 DOWNTO 0);  -- ufix7
  SIGNAL iterations_testFailure           : std_logic;  -- ufix1
  SIGNAL testFailure                      : std_logic;  -- ufix1

BEGIN
  u_mandelbrot_calculator : mandelbrot_calculator
    PORT MAP( clk => clk,
              rst => rst,
              start => start_1,
              c_real => c_real_1,  -- sfix16_En14
              c_imaginary => c_imaginary_1,  -- sfix16_En14
              ready => ready_1,
              finished => finished,
              z_real => z_real,  -- sfix16_En12
              z_imaginary => z_imaginary,  -- sfix16_En12
              iterations => iterations  -- ufix7
              );

  iterations_done_enb <= iterations_done AND rdEnb;

  
  iterations_lastAddr <= '1' WHEN ready_addr >= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  iterations_done <= iterations_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_5_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        check5_done <= '0';
      ELSIF iterations_done_enb = '1' THEN
        check5_done <= iterations_done;
      END IF;
    END IF;
  END PROCESS checkDone_5_process;

  z_imaginary_done_enb <= z_imaginary_done AND rdEnb;

  
  z_imaginary_lastAddr <= '1' WHEN ready_addr >= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  z_imaginary_done <= z_imaginary_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_4_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        check4_done <= '0';
      ELSIF z_imaginary_done_enb = '1' THEN
        check4_done <= z_imaginary_done;
      END IF;
    END IF;
  END PROCESS checkDone_4_process;

  z_real_done_enb <= z_real_done AND rdEnb;

  
  z_real_lastAddr <= '1' WHEN ready_addr >= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  z_real_done <= z_real_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_3_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        check3_done <= '0';
      ELSIF z_real_done_enb = '1' THEN
        check3_done <= z_real_done;
      END IF;
    END IF;
  END PROCESS checkDone_3_process;

  finished_done_enb <= finished_done AND rdEnb;

  
  finished_lastAddr <= '1' WHEN ready_addr >= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  finished_done <= finished_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_2_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        check2_done <= '0';
      ELSIF finished_done_enb = '1' THEN
        check2_done <= finished_done;
      END IF;
    END IF;
  END PROCESS checkDone_2_process;

  ready_done_enb <= ready_done AND rdEnb;

  
  ready_active <= '1' WHEN ready_addr /= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  enb <= rdEnb AFTER 2 ns;

  snkDonen <=  NOT snkDone;

  clk_gen: PROCESS 
  BEGIN
    clk <= '1';
    WAIT FOR 10 ns;
    clk <= '0';
    WAIT FOR 10 ns;
    IF snkDone = '1' THEN
      clk <= '1';
      WAIT FOR 10 ns;
      clk <= '0';
      WAIT FOR 10 ns;
      WAIT;
    END IF;
  END PROCESS clk_gen;

  rst_gen: PROCESS 
  BEGIN
    rst <= '1';
    WAIT FOR 2 ns;
    WAIT UNTIL rising_edge(clk);
    WAIT FOR 2 ns;
    rst <= '0';
    WAIT;
  END PROCESS rst_gen;

  resetn <=  NOT rst;

  tb_enb <= resetn AND snkDonen;

  
  rdEnb <= tb_enb WHEN snkDone = '0' ELSE
      '0';

  alpha2 <= enb AND (rdEnb AND tb_enb);

  ready_enb <= alpha2 AND ready_active;

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 8007343
  ready_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        ready_addr <= to_unsigned(16#000000#, 23);
      ELSIF ready_enb = '1' THEN
        IF ready_addr >= to_unsigned(16#7A2EAF#, 23) THEN 
          ready_addr <= to_unsigned(16#000000#, 23);
        ELSE 
          ready_addr <= ready_addr + to_unsigned(16#000001#, 23);
        END IF;
      END IF;
    END IF;
  END PROCESS ready_process;


  
  ready_lastAddr <= '1' WHEN ready_addr >= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  ready_done <= ready_lastAddr AND resetn;

  -- Delay to allow last sim cycle to complete
  checkDone_1_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        check1_done <= '0';
      ELSIF ready_done_enb = '1' THEN
        check1_done <= ready_done;
      END IF;
    END IF;
  END PROCESS checkDone_1_process;

  snkDone <= check5_done AND (check4_done AND (check3_done AND (check1_done AND check2_done)));

  -- Data source for start
  rawData_start <= '1';

  -- holdData reg for start
  stimuli_start_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        holdData_start <= 'X';
      ELSE
        holdData_start <= rawData_start;
      END IF;
    END IF;
  END PROCESS stimuli_start_process;

  stimuli_start_1: PROCESS (rawData_start, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      start_offset <= holdData_start;
    ELSE
      start_offset <= rawData_start;
    END IF;
  END PROCESS stimuli_start_1;

  start_1 <= start_offset AFTER 2 ns;

  
  start_active <= '1' WHEN start_addr /= to_unsigned(16#7A2EAF#, 23) ELSE
      '0';

  start_enb <= start_active AND (rdEnb AND tb_enb);

  -- Count limited, Unsigned Counter
  --  initial value   = 0
  --  step value      = 1
  --  count to value  = 8007343
  start_2_process : PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        start_addr <= to_unsigned(16#000000#, 23);
      ELSIF start_enb = '1' THEN
        IF start_addr >= to_unsigned(16#7A2EAF#, 23) THEN 
          start_addr <= to_unsigned(16#000000#, 23);
        ELSE 
          start_addr <= start_addr + to_unsigned(16#000001#, 23);
        END IF;
      END IF;
    END IF;
  END PROCESS start_2_process;


  c_real_addr_delay_1 <= start_addr AFTER 1 ns;

  -- Data source for c_real
  c_real_fileread: PROCESS (c_real_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "c_real.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_c_real <= signed(read_data(15 DOWNTO 0));
  END PROCESS c_real_fileread;

  -- holdData reg for c_real
  stimuli_c_real_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        holdData_c_real <= (OTHERS => 'X');
      ELSE
        holdData_c_real <= rawData_c_real;
      END IF;
    END IF;
  END PROCESS stimuli_c_real_process;

  stimuli_c_real_1: PROCESS (rawData_c_real, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      c_real_offset <= holdData_c_real;
    ELSE
      c_real_offset <= rawData_c_real;
    END IF;
  END PROCESS stimuli_c_real_1;

  c_real <= c_real_offset AFTER 2 ns;

  c_real_1 <= std_logic_vector(c_real);

  c_imaginary_addr_delay_1 <= start_addr AFTER 1 ns;

  -- Data source for c_imaginary
  c_imaginary_fileread: PROCESS (c_imaginary_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "c_imaginary.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    rawData_c_imaginary <= signed(read_data(15 DOWNTO 0));
  END PROCESS c_imaginary_fileread;

  -- holdData reg for c_imaginary
  stimuli_c_imaginary_process: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF rst = '1' THEN
        holdData_c_imaginary <= (OTHERS => 'X');
      ELSE
        holdData_c_imaginary <= rawData_c_imaginary;
      END IF;
    END IF;
  END PROCESS stimuli_c_imaginary_process;

  stimuli_c_imaginary_1: PROCESS (rawData_c_imaginary, rdEnb)
  BEGIN
    IF rdEnb = '0' THEN
      c_imaginary_offset <= holdData_c_imaginary;
    ELSE
      c_imaginary_offset <= rawData_c_imaginary;
    END IF;
  END PROCESS stimuli_c_imaginary_1;

  c_imaginary <= c_imaginary_offset AFTER 2 ns;

  c_imaginary_1 <= std_logic_vector(c_imaginary);

  ready_addr_delay_1 <= ready_addr AFTER 1 ns;

  -- Data source for ready_expected
  ready_expected_fileread: PROCESS (ready_addr_delay_1, tb_enb, rdEnb)
    FILE fp: TEXT open READ_MODE is "ready_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF rdEnb = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    ready_expected <= read_data;
  END PROCESS ready_expected_fileread;

  ready_ref <= ready_expected;

  ready_1_checker: PROCESS (clk, rst)
  BEGIN
    IF rst = '1' THEN
      ready_testFailure <= '0';
    ELSIF rising_edge(clk) THEN
      IF alpha2 = '1' AND ready_1 /= ready_ref THEN
        ready_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in ready_1: Expected " & to_hex(ready_ref) & (" Actual " & to_hex(ready_1))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS ready_1_checker;

  finished_addr_delay_1 <= ready_addr AFTER 1 ns;

  -- Data source for finished_expected
  finished_expected_fileread: PROCESS (finished_addr_delay_1, tb_enb, alpha2)
    FILE fp: TEXT open READ_MODE is "finished_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic;

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF alpha2 = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      READ(l, read_data);
    END IF;
    finished_expected <= read_data;
  END PROCESS finished_expected_fileread;

  finished_ref <= finished_expected;

  finished_checker: PROCESS (clk, rst)
  BEGIN
    IF rst = '1' THEN
      finished_testFailure <= '0';
    ELSIF rising_edge(clk) THEN
      IF alpha2 = '1' AND finished /= finished_ref THEN
        finished_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in finished: Expected " & to_hex(finished_ref) & (" Actual " & to_hex(finished))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS finished_checker;

  z_real_signed <= signed(z_real);

  z_real_addr_delay_1 <= ready_addr AFTER 1 ns;

  -- Data source for z_real_expected
  z_real_expected_fileread: PROCESS (z_real_addr_delay_1, tb_enb, alpha2)
    FILE fp: TEXT open READ_MODE is "z_real_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF alpha2 = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    z_real_expected <= signed(read_data(15 DOWNTO 0));
  END PROCESS z_real_expected_fileread;

  z_real_ref <= z_real_expected;

  z_real_signed_checker: PROCESS (clk, rst)
  BEGIN
    IF rst = '1' THEN
      z_real_testFailure <= '0';
    ELSIF rising_edge(clk) THEN
      IF alpha2 = '1' AND z_real_signed /= z_real_ref THEN
        z_real_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in z_real_signed: Expected " & to_hex(z_real_ref) & (" Actual " & to_hex(z_real_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS z_real_signed_checker;

  z_imaginary_signed <= signed(z_imaginary);

  z_imaginary_addr_delay_1 <= ready_addr AFTER 1 ns;

  -- Data source for z_imaginary_expected
  z_imaginary_expected_fileread: PROCESS (z_imaginary_addr_delay_1, tb_enb, alpha2)
    FILE fp: TEXT open READ_MODE is "z_imaginary_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(15 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF alpha2 = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    z_imaginary_expected <= signed(read_data(15 DOWNTO 0));
  END PROCESS z_imaginary_expected_fileread;

  z_imaginary_ref <= z_imaginary_expected;

  z_imaginary_signed_checker: PROCESS (clk, rst)
  BEGIN
    IF rst = '1' THEN
      z_imaginary_testFailure <= '0';
    ELSIF rising_edge(clk) THEN
      IF alpha2 = '1' AND z_imaginary_signed /= z_imaginary_ref THEN
        z_imaginary_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in z_imaginary_signed: Expected " & to_hex(z_imaginary_ref) & (" Actual " & to_hex(z_imaginary_signed))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS z_imaginary_signed_checker;

  iterations_unsigned <= unsigned(iterations);

  iterations_addr_delay_1 <= ready_addr AFTER 1 ns;

  -- Data source for iterations_expected
  iterations_expected_fileread: PROCESS (iterations_addr_delay_1, tb_enb, alpha2)
    FILE fp: TEXT open READ_MODE is "iterations_expected.dat";
    VARIABLE l: LINE;
    VARIABLE read_data: std_logic_vector(7 DOWNTO 0);

  BEGIN
    IF tb_enb /= '1' THEN
    ELSIF alpha2 = '1' AND NOT ENDFILE(fp) THEN
      READLINE(fp, l);
      HREAD(l, read_data);
    END IF;
    iterations_expected <= unsigned(read_data(6 DOWNTO 0));
  END PROCESS iterations_expected_fileread;

  iterations_ref <= iterations_expected;

  iterations_unsigned_checker: PROCESS (clk, rst)
  BEGIN
    IF rst = '1' THEN
      iterations_testFailure <= '0';
    ELSIF rising_edge(clk) THEN
      IF alpha2 = '1' AND iterations_unsigned /= iterations_ref THEN
        iterations_testFailure <= '1';
        ASSERT FALSE
          REPORT "Error in iterations_unsigned: Expected " & to_hex(iterations_ref) & (" Actual " & to_hex(iterations_unsigned))
          SEVERITY ERROR;
      END IF;
    END IF;
  END PROCESS iterations_unsigned_checker;

  testFailure <= iterations_testFailure OR (z_imaginary_testFailure OR (z_real_testFailure OR (ready_testFailure OR finished_testFailure)));

  completed_msg: PROCESS (clk)
  BEGIN
    IF rising_edge(clk) THEN
      IF snkDone = '1' THEN
        IF testFailure = '0' THEN
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (PASSED)**************"
            SEVERITY NOTE;
        ELSE
          ASSERT FALSE
            REPORT "**************TEST COMPLETED (FAILED)**************"
            SEVERITY NOTE;
        END IF;
      END IF;
    END IF;
  END PROCESS completed_msg;

END simulation;

